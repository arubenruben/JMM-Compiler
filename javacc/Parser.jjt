options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

public class Parser
{
}

PARSER_END(Parser)

SKIP :
{
	" " | "\r" | "\t" | "\n"
	|< "//" (~["\r", "\n"])* >
	| "/*" : WithinComment
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}

TOKEN:
{

	    < IMPORT: "import" >
	|   < DOT: "." >
	|   < SEMICOLON: ";" >
	|   < CLASS: "class" >
    |   < EXTENDS: "extends" >
    |   < LCUR: "{" >
    |   < RCUR: "}" >
    |   < PUBLIC: "public" >
    |   < LPAR: "(" >
    |   < RPAR: ")" >
    |   < COMMA: "," >
    |   < RETURN: "return" >
    |   < STATIC: "static" >
    |   < VOID: "void" >
    |   < MAIN: "main" >
    |   < STRING: "String" >
    |   < LREC: "[" >
    |   < RREC: "]" >
    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < IF: "if" >
    |   < ELSE: "else" >
    |   < WHILE: "while" >
    |   < EQUAL: "=" >
    |   < AND: "&&" >
    |   < LESS: "<" >
    |   < GREATER: ">" >
    |   < PLUS: "+" >
    |   < MINUS: "-" >
    |   < MULT : "*" >
    |   < DIV : "/">
    |   < LENGTH : "length">
    |   < TRUE : "true">
    |   < FALSE: "false">
    |   < THIS:"this">
    |   < NEW:"new">
    |   < NOT:"!">
    |   < IDENTIFIER: <LETTER> (<LETTER>|<INTEGERLITERAL> )*>
    |   < LETTER: ["a"-"z","A"-"Z","_"]>
    |   < INTEGERLITERAL: (["0"-"9"])+ >

}


SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}


void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}


void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>]
    <LCUR>(VarDeclaration())* (MethodDeclaration())*<RCUR>
}

void VarDeclaration() : {}
{
    TypeWithIdentifier()<IDENTIFIER><SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC>(ClassMethod() | StaticFunction() )

}
void ClassMethod():{}
{
    TypeWithIdentifier() <IDENTIFIER> <LPAR> [TypeWithIdentifier() <IDENTIFIER> (<COMMA> TypeWithIdentifier() <IDENTIFIER>)*] <RPAR>
        <LCUR>
            (Statement())*
            <RETURN> Expression() <SEMICOLON>
        <RCUR>

}
void StaticFunction():{}
{
    <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LREC> <RREC> <IDENTIFIER> <RPAR>
            <LCUR>
                (Statement())*
            <RCUR>
}

void NativeType():{}
{
    <INT> [<LREC> <RREC>] | <BOOLEAN>
}

void TypeWithIdentifier() : {}
{
    NativeType() | <IDENTIFIER>
}

void Statement() : {}{
    <LCUR> (Statement())* <RCUR>
    |
    <IF> <LPAR> Expression() <RPAR>
        Statement()
    <ELSE>
        Statement()
    |
    <WHILE> <LPAR> Expression() <RPAR>
        Statement()
    |

    Expression() <SEMICOLON>


}

//According to https://introcs.cs.princeton.edu/java/11precedence/
void Expression() : {}
{
    ExpressionLevel4Priority()|(Expression() <EQUAL> ExpressionLevel4Priority())
}
void ExpressionLevel4Priority():{}
{
    ExpressionLevel11Priority()| (ExpressionLevel4Priority() <AND> ExpressionLevel11Priority())
}
void ExpressionLevel11Priority():{}
{
    ExpressionLevel12Priority()| (ExpressionLevel11Priority() (<PLUS>|<MINUS>)ExpressionLevel12Priority())
}
void ExpressionLevel12Priority():{}
{
    ExpressionLevel13Priority()| (ExpressionLevel12Priority() (<MULT>|<DIV>) ExpressionLevel13Priority())
}
void ExpressionLevel13Priority():{}
{
    ExpressionLevel16Priority() |(ExpressionLevel13Priority() <NEW>ExpressionLevel14Priority() )
}
void ExpressionLevel14Priority():{}
{
    ExpressionLevel16Priority() | (ExpressionLevel14Priority() <NOT> ExpressionLevel16Priority() )
}

void ExpressionLevel16Priority():{}
{
    Terminals() | (<LPAR>Expression()<RPAR>)|(<LREC>Expression()<RREC>)|(<DOT>Expression())
}
void Terminals():{}
{
    <IDENTIFIER>|<INTEGERLITERAL> |<TRUE>|<FALSE>|<THIS>
}


void ArrayInstation(): {}
{
    <INT> <LREC> Expression() <RREC>
}

void ObjectInstation(): {}
{
    <IDENTIFIER> <LPAR> <RPAR>
}
/*
void Expression(): {}
{
    //TODO Alter precendences

    Expression() <DOT> <LENGTH>
    |
    Expression() <DOT> Identifier() <LPAR> [Expression() (<COMMA> Expression())* ] <RPAR>
    |
    <NEW> <INT> <LREC> Expression() <RREC>
    |
    <NEW> Identifier() <LPAR> <RPAR>
}
 */