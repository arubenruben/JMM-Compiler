options
{
    LOOKAHEAD=1;
    MULTI = true;
}

PARSER_BEGIN(Parser)
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.io.FileReader;
import java.io.FileNotFoundException;
public class Parser
{
    private int numberOfSyntaxErrors = 0;
    public static int MAX_NUMBER_SYNTAX_ERRORS = 10;
    private List<String> fileLines = new ArrayList<String>();
    private String filename;


    private void reportSyntaxError(ParseException e){
        String errorType = "Syntax";
        System.out.println("------------------------------------------------");
        System.out.println("Error NÂº" + numberOfSyntaxErrors + ":");
        System.out.println("Type of error: " + errorType);

        String line = "";
        String indicator = "";

        if(!fileLines.isEmpty()){
            line = fileLines.get(e.currentToken.next.beginLine - 1);
            for(int i = 0; i < e.currentToken.next.beginColumn - 1; i++) {
                if (line.charAt(i) == '\t')
                    indicator += "\t";
                else
                    indicator += " ";
            }
            System.out.println("Error place: line " + e.currentToken.next.beginLine + " column " + indicator.length());
            System.out.println(line);
            indicator += "^";
            System.out.println(indicator);
        }

        System.out.println("Found: " + e.currentToken.next);
        System.out.print("Expected: ");
        for (int [] expectedTokenArray : e.expectedTokenSequences){
                for(int expectedToken : expectedTokenArray){
                    System.out.print(e.tokenImage[expectedToken] + ",");
                }
        }
        System.out.println();
        System.out.println("------------------------------------------------");
    }

    public void setFileLines(String code){
       Scanner s = new Scanner(code);
       while (s.hasNext()) {
           fileLines.add(s.nextLine());
       }
    }

    private void handleWhileSyntaxError(ParseException e) throws ParseException{

        reportSyntaxError(e);

        Token t;
        do {
            t = getToken(1);
            if (t.kind == EOF || t.kind == LCUR || t.kind == IF || t.kind == WHILE)
                break;
            t = getNextToken();
        } while (t.kind != RPAR);

        this.numberOfSyntaxErrors++;
        if (this.numberOfSyntaxErrors >= MAX_NUMBER_SYNTAX_ERRORS) {
          throw new ParseException("Parser caught the maximum amount of errors (" + MAX_NUMBER_SYNTAX_ERRORS + " errors).");
        }
    }
}


PARSER_END(Parser)

SKIP :
{
	" " | "\r" | "\t" | "\n"
	|< "//" (~["\r", "\n"])* >
	| "/*" : WithinComment
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}

TOKEN:
{
	< IMPORT: "import" >
	|   < DOT: "." >
	|   < SEMICOLON: ";" >
	|   < CLASS: "class" >
    |   < EXTENDS: "extends" >
    |   < LCUR: "{" >
    |   < RCUR: "}" >
    |   < PUBLIC: "public" >
    |   < LPAR: "(" >
    |   < RPAR: ")" >
    |   < COMMA: "," >
    |   < RETURN: "return" >
    |   < STATIC: "static" >
    |   < VOID: "void" >
    |   < MAIN: "main" >
    |   < STRING: "String" >
    |   < LREC: "[" >
    |   < RREC: "]" >
    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < IF: "if" >
    |   < ELSE: "else" >
    |   < WHILE: "while" >
    |   < EQUAL: "=" >
    |   < AND: "&&" >
    |   < LESS: "<" >
    |   < GREATER: ">" >
    |   < PLUS: "+" >
    |   < MINUS: "-" >
    |   < MULT : "*" >
    |   < DIV : "/">
    |   < LENGTH : "length">
    |   < TRUE : "true">
    |   < FALSE: "false">
    |   < THIS:"this">
    |   < NEW:"new">
    |   < NOT:"!">
    |   < IDENTIFIER: <LETTER> (<LETTER>|<INTEGERLITERAL> )*>
    |   < LETTER: ["a"-"z","A"-"Z","_"]>
    |   < INTEGERLITERAL: (["0"-"9"])+ >

}


SimpleNode Program(): {}
{
    { this.numberOfSyntaxErrors = 0; }
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}
void ImportDeclaration() #void : {}
{
    (Import())*
}
void Import() #Import:{Token t;}
{
    <IMPORT>
        ImportPath()
    <SEMICOLON>
}
void ImportPath():{}
{
    Identifier()
    (<DOT> Identifier())*
}
void ClassDeclaration() #ClassDeclaration: {Token t;}
{
    <CLASS> t= <IDENTIFIER> {jjtThis.value=t.image;}
     [<EXTENDS> t=<IDENTIFIER> {jjtThis.value=t.image;} #Extends]
    <LCUR>(VarDeclaration())* (MethodDeclaration())*<RCUR>
}
void Type() #Type:{}
{
    <INT> [<LREC> <RREC>] | <BOOLEAN>| Identifier()
}
void VarDeclaration() #VarDeclaration: {Token t;}
{
    Type() t=<IDENTIFIER> {jjtThis.value=t.image;}<SEMICOLON>
}
void MethodDeclaration() #void : {}
{
    <PUBLIC>(ClassMethod() | StaticMethod() )

}
void ClassMethod()#ClassMethod:{Token t;}
{
    Type() t=<IDENTIFIER> {jjtThis.value=t.image;} <LPAR>ClassMethodParameters()<RPAR> <LCUR>
         MethodBody()
        <RETURN> Expression() <SEMICOLON>
    <RCUR>

}
void ClassMethodParameters() #ClassMethodParameters:{}
{
    [Type() Identifier() (<COMMA> Type() Identifier())*]
}
void StaticMethod()#StaticMethod:{Token t;}
{
    <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LREC> <RREC> t=<IDENTIFIER> {jjtThis.value=t.image;} <RPAR><LCUR>
        MethodBody()
        <RETURN> Expression() <SEMICOLON>
    <RCUR>
}
void MethodBody()#void:{}
{
    (LOOKAHEAD(2)
    VarDeclaration())*
    (Statement())*
}
void Statement() #void: {}{
    BlockStatement()
    |
    IfStatement()
    |
    WhileStatement()
    |
    LOOKAHEAD(2)
    AttributionStatement()
    |
    Expression() <SEMICOLON>

}
void BlockStatement() #void:{}
{
    <LCUR> (Statement())* <RCUR>
}
void IfStatement():{}
{
    <IF> <LPAR> Expression() <RPAR>
        Statement()
    <ELSE>
        Statement()
}
void AttributionStatement()#Attribution:{}
{
    Identifier() ((<LREC> Expression() <RREC> <EQUAL> Expression())|(<EQUAL> Expression())) <SEMICOLON>
}

//According to https://introcs.cs.princeton.edu/java/11precedence/
void WhileStatement()#While: {}
{
    try {
    <WHILE> <LPAR> Expression() <RPAR>
    }
    catch (ParseException e) {
        handleWhileSyntaxError(e);
    }
    Statement()
}
void Expression() #void : {}
{
    ExpressionLevel9Priority() LessExpression()
}
void ExpressionLevel9Priority()#void:{}
{
    ExpressionLevel11Priority() AndExpression()
}
void LessExpression()#void:{}
{
    [<LESS> ExpressionLevel9Priority() LessExpression() #Less(2) ]
}
void ExpressionLevel11Priority()#void:{}
{
    ExpressionLevel12Priority() AddSubExpression()
}
void AndExpression()#void:{}
{
    [<AND> ExpressionLevel11Priority() AndExpression() #And(2) ]
}
void ExpressionLevel12Priority()#void:{}
{
    ExpressionLevel14Priority() MultDivExpression()
}
void AddSubExpression()#void:{}
{
    [
    (<PLUS>ExpressionLevel12Priority()) #Add(2)
    |
    <MINUS>ExpressionLevel12Priority() #Sub(2)
    AddSubExpression()]
}
void ExpressionLevel14Priority()#void:{}
{
    ExpressionLevel16_1Priority() NotExpression()
}
void MultDivExpression()#void:{}
{
    [
    (<MULT>ExpressionLevel14Priority() #Mult(2)
    |<DIV> ExpressionLevel14Priority()) #Div(2)
    MultDivExpression()]
}
void NotExpression()#void: {}
{
   [<NOT> ExpressionLevel16_1Priority() NotExpression() #Not(1)]
}
void ExpressionLevel16Priority()#void:{}
{
    Terminals() | (<LPAR>Expression()<RPAR>) | (<LREC>Expression() <RREC>)
}
void ExpressionLevel16_1Priority()#void:{}
{
    ExpressionLevel16Priority() DotExpression()
}
void DotExpression()#void:{}
{
    [<DOT>(<LENGTH>|(<IDENTIFIER><LPAR>[Expression() (<COMMA> Expression())* ] <RPAR> )) DotExpression() ]
}
void Terminals()#void:{}
{
    Identifier()|<INTEGERLITERAL>#Numeric|<TRUE>#Boolean|<FALSE>#Boolean|<THIS> #This
    |
    ExpressionNew() #New
}
void ExpressionNew()#void:{}
{
    <NEW>
    [(<INT> <LREC> Expression() <RREC>)
    |
    (Identifier() <LPAR> <RPAR> )]
}
void Identifier()#Identifier:{}
{
    <IDENTIFIER>
}